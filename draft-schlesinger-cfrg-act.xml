<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.29 (Ruby 2.6.10) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>


<rfc ipr="trust200902" docName="draft-schlesinger-cfrg-act-latest" category="info" consensus="true" submissionType="IRTF" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="ACT">Anonymous Credit Tokens</title>

    <author fullname="Samuel Schlesinger">
      <organization>Google</organization>
      <address>
        <email>sgschlesinger@gmail.com</email>
      </address>
    </author>
    <author fullname="Jonathan Katz">
      <organization>Google</organization>
      <address>
        <email>jkcrypto@google.com</email>
      </address>
    </author>

    <date year="2025" month="June" day="04"/>

    <area>SEC</area>
    <workgroup>CFRG</workgroup>
    <keyword>anonymous credentials</keyword> <keyword>privacy</keyword> <keyword>cryptography</keyword> <keyword>zero-knowledge proofs</keyword> <keyword>BBS signatures</keyword> <keyword>keyed verification</keyword>

    <abstract>


<?line 94?>

<t>This document specifies Anonymous Credit Tokens (ACT), a privacy-preserving payment protocol based on keyed-verification anonymous credentials. The protocol enables issuers to grant numerical credit values to clients, who can later redeem these credits anonymously while preventing double-spending through the use of nullifiers. The scheme uses BBS-style signatures and zero-knowledge proofs to ensure both security and privacy.</t>

<t>Anonymous Credit Tokens are particularly suitable for web services that need to implement rate limiting, resource allocation, or micropayments while preserving user privacy. The protocol supports partial spending, allowing clients to spend a portion of their credits and receive change in the form of a new anonymous token.</t>

<t>This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>



    </abstract>

    <note title="About This Document" removeInRFC="true">
      <t>
        The latest revision of this draft can be found at <eref target="https://samuelschlesinger.github.io/ietf-anonymous-credit-tokens/draft-schlesinger-cfrg-act.html"/>.
        Status information for this document may be found at <eref target="https://datatracker.ietf.org/doc/draft-schlesinger-cfrg-act/"/>.
      </t>
      <t>
        Discussion of this document takes place on the
        CFRG Research Group mailing list (<eref target="mailto:cfrg@ietf.org"/>),
        which is archived at <eref target="https://mailarchive.ietf.org/arch/browse/cfrg/"/>.
        Subscribe at <eref target="https://www.ietf.org/mailman/listinfo/cfrg/"/>.
      </t>
      <t>Source for this draft and an issue tracker can be found at
        <eref target="https://github.com/SamuelSchlesinger/ietf-anonymous-credit-tokens"/>.</t>
    </note>


  </front>

  <middle>


<?line 102?>

<section anchor="introduction"><name>Introduction</name>

<t>Many online services need mechanisms to allocate resources, implement rate limiting, or process micropayments. Traditional approaches to these problems typically require tracking user identity, which raises privacy concerns. Anonymous Credit Tokens (ACT) provide a cryptographic solution that enables services to issue and track credits without linking transactions to user identities.</t>

<t>The Anonymous Credit Token protocol is a specialization of keyed-verification anonymous credentials <xref target="KVAC"/> that focuses on numerical credit values. It allows:</t>

<t><list style="numbers" type="1">
  <t><strong>Anonymous Issuance</strong>: An issuer can grant credits to a client without learning any client-specific information beyond the credit amount.</t>
  <t><strong>Anonymous Spending</strong>: Clients can spend their credits without revealing their identity or linking multiple transactions.</t>
  <t><strong>Partial Spending</strong>: Clients can spend a portion of their credits and receive the remainder as a new anonymous token.</t>
  <t><strong>Double-Spend Prevention</strong>: Each credit token has an associated nullifier that prevents the same credits from being spent multiple times.</t>
</list></t>

<section anchor="use-cases"><name>Use Cases</name>

<t>Anonymous Credit Tokens can be applied to various scenarios:</t>

<t><list style="symbols">
  <t><strong>Rate Limiting</strong>: Services can issue daily credit allowances that users spend anonymously for API calls or resource access.</t>
  <t><strong>Privacy-Preserving Micropayments</strong>: Users can purchase credit bundles and spend them over time without creating a transaction history.</t>
  <t><strong>Anonymous Ticketing</strong>: Event organizers can issue transferable tickets that can be verified without tracking ownership changes.</t>
  <t><strong>Resource Allocation</strong>: Cloud services can allocate computational resources using credits while preserving user privacy.</t>
</list></t>

</section>
<section anchor="protocol-overview"><name>Protocol Overview</name>

<t>The protocol involves two parties: an issuer (typically a service provider) and clients (users of the service). The interaction follows three main phases:</t>

<t><list style="numbers" type="1">
  <t><strong>Setup</strong>: The issuer generates a key pair and publishes the public key.</t>
  <t><strong>Issuance</strong>: A client requests credits from the issuer. The issuer creates a blind signature on the credit value and a client-chosen nullifier, producing a credit token.</t>
  <t><strong>Spending</strong>: To spend credits, the client reveals the nullifier and proves possession of a valid token with sufficient balance. The issuer verifies the proof, checks the nullifier hasn't been used before, and issues a new token for any remaining balance.</t>
</list></t>

</section>
<section anchor="design-goals"><name>Design Goals</name>

<t>The protocol is designed with the following goals:</t>

<t><list style="symbols">
  <t><strong>Privacy</strong>: The issuer cannot link credit tokens to specific clients or link multiple transactions by the same client.</t>
  <t><strong>Security</strong>: Clients cannot spend more credits than they possess or use the same credits multiple times.</t>
  <t><strong>Efficiency</strong>: All operations should be computationally efficient, suitable for high-volume web services.</t>
  <t><strong>Simplicity</strong>: The protocol should be straightforward to implement and integrate into existing systems.</t>
</list></t>

</section>
<section anchor="relation-to-existing-work"><name>Relation to Existing Work</name>

<t>This protocol builds upon several cryptographic primitives:</t>

<t><list style="symbols">
  <t><strong>BBS Signatures</strong> <xref target="BBS"/>: The core signature scheme that enables efficient proofs of possession.</t>
  <t><strong>Sigma Protocols</strong> <xref target="ORRU-SIGMA"/>: The zero-knowledge proof framework used for spending proofs.</t>
  <t><strong>Fiat-Shamir Transform</strong> <xref target="ORRU-FS"/>: The technique to make the interactive proofs non-interactive.</t>
</list></t>

<t>The protocol can be viewed as a specialized instantiation of keyed-verification anonymous credentials <xref target="KVAC"/> optimized for numerical values and partial spending.</t>

</section>
</section>
<section anchor="conventions-and-definitions"><name>Conventions and Definitions</name>

<t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
"<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
described in BCPÂ 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<?line -18?>

<section anchor="notation"><name>Notation</name>

<t>This document uses the following notation:</t>

<t><list style="symbols">
  <t><spanx style="verb">||</spanx>: Concatenation of byte strings</t>
  <t><spanx style="verb">x &lt;- S</spanx>: Sampling x uniformly at random from the set S</t>
  <t><spanx style="verb">x := y</spanx>: Assignment of the value y to the variable x</t>
  <t><spanx style="verb">[n]</spanx>: The set of integers {0, 1, ..., n-1}</t>
  <t><spanx style="verb">|x|</spanx>: The length of byte string x</t>
  <t><spanx style="verb">0x</spanx> prefix: Hexadecimal values</t>
</list></t>

</section>
<section anchor="data-types"><name>Data Types</name>

<t>The protocol uses the following data types:</t>

<t><list style="symbols">
  <t><strong>Scalar</strong>: An integer modulo the group order q</t>
  <t><strong>Element</strong>: A point on the Ristretto curve</t>
  <t><strong>ByteString</strong>: A sequence of bytes</t>
</list></t>

</section>
<section anchor="cryptographic-parameters"><name>Cryptographic Parameters</name>

<t>The protocol uses the Ristretto group <xref target="RISTRETTO"/>, which provides a prime-order group abstraction over Curve25519. The key parameters are:</t>

<t><list style="symbols">
  <t><strong>q</strong>: The prime order of the group (2^252 + 27742317777372353535851937790883648493)</t>
  <t><strong>G</strong>: The standard generator of the Ristretto group</t>
  <t><strong>L</strong>: The bit length for credit values (configurable, typically 128 bits)</t>
</list></t>

</section>
</section>
<section anchor="protocol-specification"><name>Protocol Specification</name>

<section anchor="system-parameters"><name>System Parameters</name>

<t>The protocol requires the following system parameters:</t>

<figure><artwork><![CDATA[
Parameters:
  - G: Generator of the Ristretto group
  - H1, H2, H3: Additional generators for commitments
  - L: Bit length for credit values (configurable, must satisfy L < 252)
]]></artwork></figure>

<t>The generators H1, H2, and H3 <bcp14>MUST</bcp14> be generated deterministically from a nothing-up-my-sleeve value to ensure they are independent of each other and of G. This prevents attacks where malicious parameters could compromise security. Note that these generators are independent of the choice of L:</t>

<figure><artwork><![CDATA[
GenerateParameters(domain_separator):
  Input:
    - domain_separator: ByteString identifying the deployment
  Output:
    - params: System parameters (H1, H2, H3)

  Steps:
    1. seed = BLAKE3(domain_separator)
    2. rng = ChaCha20RNG(seed)
    3. H1 = HashToRistretto(rng.next())
    4. H2 = HashToRistretto(rng.next())
    5. H3 = HashToRistretto(rng.next())
    6. return (H1, H2, H3)
]]></artwork></figure>

<t>The domain_separator <bcp14>MUST</bcp14> be unique for each deployment to ensure cryptographic isolation between different services. Each deployment <bcp14>SHOULD</bcp14> use a domain separator that identifies the specific service, organization, or use case, such as "myservice-act-v1" or "example-corp-credits-v1". Using generic domain separators like "anonymous-credit-tokens-v1" across multiple deployments creates security risks through parameter collision and <bcp14>MUST</bcp14> be avoided in production systems.</t>

</section>
<section anchor="key-generation"><name>Key Generation</name>

<t>The issuer generates a key pair as follows:</t>

<figure><artwork><![CDATA[
KeyGen():
  Input: None
  Output:
    - sk: Private key (Scalar)
    - pk: Public key (Element)

  Steps:
    1. x <- Zq
    2. W = G * x
    3. sk = x
    4. pk = W
    5. return (sk, pk)
]]></artwork></figure>

</section>
<section anchor="token-issuance"><name>Token Issuance</name>

<t>The issuance protocol is an interactive protocol between a client and the issuer:</t>

<section anchor="client-issuance-request"><name>Client: Issuance Request</name>

<figure><artwork><![CDATA[
IssueRequest(pk, c):
  Input:
    - pk: Issuer's public key
    - c: Credit amount (0 <= c < 2^L)
  Output:
    - request: Issuance request
    - state: Client state for later verification

  Steps:
    1. k <- Zq  // Token identifier
    2. r <- Zq  // Blinding factor
    3. K = H2 * k + H3 * r
    4. // Generate proof of knowledge of k, r
    5. k' <- Zq
    6. r' <- Zq
    7. K1 = H2 * k' + H3 * r'
    8. transcript = CreateTranscript("request")
    9. AddToTranscript(transcript, K)
    10. AddToTranscript(transcript, K1)
    11. gamma = GetChallenge(transcript)
    12. k_bar = k' + gamma * k
    13. r_bar = r' + gamma * r
    14. request = (K, gamma, k_bar, r_bar)
    15. state = (k, r, c)
    16. return (request, state)
]]></artwork></figure>

</section>
<section anchor="issuer-issuance-response"><name>Issuer: Issuance Response</name>

<figure><artwork><![CDATA[
Issue(sk, request, c):
  Input:
    - sk: Issuer's private key
    - request: Client's issuance request
    - c: Credit amount to issue
  Output:
    - response: Issuance response or INVALID

  Steps:
    1. Parse request as (K, gamma, k_bar, r_bar)
    2. // Verify proof of knowledge
    3. K1 = H2 * k_bar + H3 * r_bar - K * gamma
    4. transcript = CreateTranscript("request")
    5. AddToTranscript(transcript, K)
    6. AddToTranscript(transcript, K1)
    7. if GetChallenge(transcript) != gamma:
    8.     return INVALID
    9. // Create BBS signature
    10. e <- Zq
    11. A = (G + H1 * c + K)^(1/(e + sk))
    12. // Generate proof of correct computation
    13. alpha <- Zq
    14. Y_A = A * alpha
    15. Y_G = G * alpha
    16. X_A = G + H1 * c + K
    17. X_G = G * e + pk
    18. transcript_resp = CreateTranscript("respond")
    19. AddToTranscript(transcript_resp, c)
    20. AddToTranscript(transcript_resp, e)
    21. AddToTranscript(transcript_resp, A)
    22. AddToTranscript(transcript_resp, X_A)
    23. AddToTranscript(transcript_resp, X_G)
    24. AddToTranscript(transcript_resp, Y_A)
    25. AddToTranscript(transcript_resp, Y_G)
    26. gamma_resp = GetChallenge(transcript_resp)
    27. z = gamma_resp * (sk + e) + alpha
    28. response = (A, e, gamma_resp, z, c)
    29. return response
]]></artwork></figure>

</section>
<section anchor="client-token-verification"><name>Client: Token Verification</name>

<figure><artwork><![CDATA[
VerifyIssuance(pk, request, response, state):
  Input:
    - pk: Issuer's public key
    - request: The issuance request sent
    - response: Issuer's response
    - state: Client state from request generation
  Output:
    - token: Credit token or INVALID

  Steps:
    1. Parse response as (A, e, gamma_resp, z, c_resp)
    2. Parse state as (k, r, c)
    3. if c_resp != c:
    4.     return INVALID
    5. // Verify proof
    6. K = H2 * k + H3 * r
    7. X_A = G + H1 * c + K
    8. X_G = G * e + pk
    9. Y_A = A * z - X_A * gamma_resp
    10. Y_G = G * z - X_G * gamma_resp
    11. transcript_resp = CreateTranscript("respond")
    12. AddToTranscript(transcript_resp, c)
    13. AddToTranscript(transcript_resp, e)
    14. AddToTranscript(transcript_resp, A)
    15. AddToTranscript(transcript_resp, X_A)
    16. AddToTranscript(transcript_resp, X_G)
    17. AddToTranscript(transcript_resp, Y_A)
    18. AddToTranscript(transcript_resp, Y_G)
    19. if GetChallenge(transcript_resp) != gamma_resp:
    20.     return INVALID
    21. token = (A, e, k, r, c)
    22. return token
]]></artwork></figure>

</section>
</section>
<section anchor="token-spending"><name>Token Spending</name>

<t>The spending protocol allows a client to spend s credits from a token containing c credits (where s &lt;= c):</t>

<section anchor="client-spend-proof-generation"><name>Client: Spend Proof Generation</name>

<figure><artwork><![CDATA[
ProveSpend(token, s):
  Input:
    - token: Credit token (A, e, k, r, c)
    - s: Amount to spend (0 <= s <= c)
  Output:
    - proof: Spend proof
    - state: Client state for receiving change

  Steps:
    1. // Randomize the signature
    2. r1, r2 <- Zq
    3. B = G + H1 * c + H2 * k + H3 * r
    4. A' = A * r1 * r2
    5. B_bar = B * r1
    6. r3 = 1/r1

    7. // Decompose c - s into bits
    8. m = c - s
    9. (i[0], ..., i[L-1]) = BitDecompose(m)  // See Section 3.7

    10. // Create commitments for each bit
    11. k* <- Zq
    12. For j = 0 to L-1:
    13.     s[j] <- Zq
    14.     if j == 0:
    15.         Com[j] = H1 * i[j] + H2 * k* + H3 * s[j]
    16.     else:
    17.         Com[j] = H1 * i[j] + H3 * s[j]

    18. // Generate range proof (see Section 3.5.1)
    19. range_proof = GenerateRangeProof(i, k*, s, Com)

    20. // Complete sigma protocol
    21. K' = Product(Com[j] * 2^j for j in [L])
    22. // Generate remaining proof components
    23. c' <- Zq
    24. r' <- Zq
    25. e' <- Zq
    26. r2' <- Zq
    27. r3' <- Zq
    28.
    29. // Compute first round messages
    30. A1 = A' * e' + B_bar * r2'
    31. A2 = B_bar * r3' + H1 * c' + H3 * r'
    32.
    33. // Prepare range proof challenges
    34. k' <- Zq
    35. s' <- Zq
    36. C = H1 * (-c') + H2 * k' + H3 * s'
    37.
    38. // Generate challenge using transcript
    39. transcript = CreateTranscript("spend")
    40. AddToTranscript(transcript, k)
    41. AddToTranscript(transcript, A')
    42. AddToTranscript(transcript, B_bar)
    43. AddToTranscript(transcript, A1)
    44. AddToTranscript(transcript, A2)
    45. For j = 0 to L-1:
    46.     AddToTranscript(transcript, Com[j])
    47. For j = 0 to L-1:
    48.     AddToTranscript(transcript, range_proof.C'[j][0])
    49.     AddToTranscript(transcript, range_proof.C'[j][1])
    50. AddToTranscript(transcript, C)
    51. gamma = GetChallenge(transcript)
    52.
    53. // Compute responses
    54. e_bar = -gamma * e + e'
    55. r2_bar = gamma * r2 + r2'
    56. r3_bar = gamma * r3 + r3'
    57. c_bar = -gamma * c + c'
    58. r_bar = -gamma * r + r'
    59. k_bar = gamma * k* + k'
    60. r* = Sum(2^j * s[j] for j in [L])
    61. s_bar = gamma * r* + s'
    62.
    63. // Construct proof
    64. proof = SpendProof(k, s, A', B_bar, Com, gamma, e_bar,
    65.                    r2_bar, r3_bar, c_bar, r_bar,
    66.                    range_proof.w00, range_proof.w01,
    67.                    range_proof.gamma0, range_proof.z,
    68.                    k_bar, s_bar)
    69. state = (k*, r*, m)
    70. return (proof, state)
]]></artwork></figure>

</section>
<section anchor="issuer-spend-verification-and-refund"><name>Issuer: Spend Verification and Refund</name>

<figure><artwork><![CDATA[
VerifyAndRefund(sk, proof):
  Input:
    - sk: Issuer's private key
    - proof: Client's spend proof
  Output:
    - refund: Refund for remaining credits or INVALID

  Steps:
    1. Parse proof and extract nullifier k
    2. // Check nullifier hasn't been used
    3. if k in used_nullifiers:
    4.     return INVALID
    5. // Verify the proof (see Section 3.5.2)
    6. if not VerifySpendProof(pk, proof):
    7.     return INVALID
    8. // Record nullifier
    9. used_nullifiers.add(k)
    10. // Issue refund for remaining balance
    11. K' = Product(Com[j] * 2^j for j in [L])
    12. refund = IssueRefund(sk, K')
    13. return refund
]]></artwork></figure>

</section>
<section anchor="refund-issuance"><name>Refund Issuance</name>

<t>After verifying a spend proof, the issuer creates a refund token for the remaining balance:</t>

<figure><artwork><![CDATA[
IssueRefund(sk, K'):
  Input:
    - sk: Issuer's private key
    - K': Commitment to remaining balance and new nullifier
  Output:
    - refund: Refund response

  Steps:
    1. // Create new BBS signature on remaining balance
    2. e* <- Zq
    3. X_A* = G + K'
    4. A* = X_A* ^ (1/(e* + sk))

    5. // Generate proof of correct computation
    6. alpha <- Zq
    7. Y_A = A* * alpha
    8. Y_G = G * alpha
    9. X_G = G * e* + pk

    10. // Create challenge using transcript
    11. transcript = CreateTranscript("refund")
    12. AddToTranscript(transcript, e*)
    13. AddToTranscript(transcript, A*)
    14. AddToTranscript(transcript, X_A*)
    15. AddToTranscript(transcript, X_G)
    16. AddToTranscript(transcript, Y_A)
    17. AddToTranscript(transcript, Y_G)
    18. gamma = GetChallenge(transcript)

    19. // Compute response
    20. z = gamma * (sk + e*) + alpha

    21. refund = (A*, e*, gamma, z)
    22. return refund
]]></artwork></figure>

</section>
<section anchor="client-refund-token-construction"><name>Client: Refund Token Construction</name>

<t>The client verifies the refund and constructs a new credit token:</t>

<figure><artwork><![CDATA[
ConstructRefundToken(pk, spend_proof, refund, state):
  Input:
    - pk: Issuer's public key
    - spend_proof: The spend proof sent to issuer
    - refund: Issuer's refund response
    - state: Client state (k*, r*, m)
  Output:
    - token: New credit token or INVALID

  Steps:
    1. Parse refund as (A*, e*, gamma, z)
    2. Parse state as (k*, r*, m)

    3. // Reconstruct commitment
    4. K' = Product(spend_proof.Com[j] * 2^j for j in [L])
    5. X_A* = G + K'
    6. X_G = G * e* + pk

    7. // Verify proof
    8. Y_A = A* * z - X_A* * gamma
    9. Y_G = G * z - X_G * gamma

    10. // Check challenge using transcript
    11. transcript = CreateTranscript("refund")
    12. AddToTranscript(transcript, e*)
    13. AddToTranscript(transcript, A*)
    14. AddToTranscript(transcript, X_A*)
    15. AddToTranscript(transcript, X_G)
    16. AddToTranscript(transcript, Y_A)
    17. AddToTranscript(transcript, Y_G)
    18. if GetChallenge(transcript) != gamma:
    19.     return INVALID

    20. // Construct new token
    21. token = (A*, e*, k*, r*, m)
    22. return token
]]></artwork></figure>

</section>
<section anchor="spend-verification"><name>Spend Proof Verification</name>

<t>The issuer verifies a spend proof as follows:</t>

<figure><artwork><![CDATA[
VerifySpendProof(pk, proof):
  Input:
    - pk: Issuer's public key
    - proof: Spend proof from client
  Output:
    - valid: Boolean indicating if proof is valid

  Steps:
    1. Parse proof as (k, s, A', B_bar, Com, gamma, e_bar,
                      r2_bar, r3_bar, c_bar, r_bar, w00, w01,
                      gamma0, z, k_bar, s_bar)

    2. // Check A' is not identity
    3. if A' == Identity:
    4.     return false

    5. // Compute issuer's view of signature
    6. A_bar = A' * sk  // This requires the issuer's private key
    7. H1_prime = G + H2 * k  // Spending amount s is added to this later

    8. // Verify sigma protocol
    9. A1 = A' * e_bar + B_bar * r2_bar - A_bar * gamma
    10. A2 = B_bar * r3_bar + H1 * c_bar + H3 * r_bar - H1_prime * gamma

    11. // Verify range proof
    12. For j = 0 to L-1:
    13.     gamma1[j] = gamma - gamma0[j]
    14.     C[j][0] = Com[j]
    15.     C[j][1] = Com[j] / H1

    16. // Verify bit 0 (with k* component)
    17. C'[0][0] = H2 * w00 + H3 * z[0][0] - C[0][0] * gamma0[0]
    18. C'[0][1] = H2 * w01 + H3 * z[0][1] - C[0][1] * gamma1[0]

    19. // Verify remaining bits
    20. For j = 1 to L-1:
    21.     C'[j][0] = H3 * z[j][0] - C[j][0] * gamma0[j]
    22.     C'[j][1] = H3 * z[j][1] - C[j][1] * gamma1[j]

    23. // Verify final commitment
    24. K' = Product(Com[j] * 2^j for j in [L])
    25. Com_total = H1 * s + K'
    26. C_final = H1 * (-c_bar) + H2 * k_bar + H3 * s_bar - Com_total * gamma

    27. // Recompute challenge using transcript
    28. transcript = CreateTranscript("spend")
    29. AddToTranscript(transcript, k)
    30. AddToTranscript(transcript, A')
    31. AddToTranscript(transcript, B_bar)
    32. AddToTranscript(transcript, A1)
    33. AddToTranscript(transcript, A2)
    34. For j = 0 to L-1:
    35.     AddToTranscript(transcript, Com[j])
    36. For j = 0 to L-1:
    37.     AddToTranscript(transcript, C'[j][0])
    38.     AddToTranscript(transcript, C'[j][1])
    39. AddToTranscript(transcript, C_final)
    40. gamma_check = GetChallenge(transcript)

    41. // Verify challenge matches
    42. if gamma != gamma_check:
    43.     return false

    44. return true
]]></artwork></figure>

</section>
<section anchor="range-proof"><name>Range Proof Generation</name>

<t>The range proof demonstrates that c - s &gt;= 0 without revealing the actual values. It uses a binary decomposition and proves each bit is either 0 or 1:</t>

<figure><artwork><![CDATA[
GenerateRangeProof(bits, k*, s, Com):
  Input:
    - bits: Binary decomposition of c - s
    - k*, s: Randomness values
    - Com: Commitments to each bit
  Output:
    - range_proof: Zero-knowledge range proof

  Steps:
    1. // Initialize arrays for proof components
    2. C = array[L][2]
    3. C' = array[L][2]
    4. gamma0 = array[L]
    5. w = array[L]
    6. z = array[L][2]

    7. // Process bit 0 (includes k*)
    8. C[0][0] = Com[0]
    9. C[0][1] = Com[0] / H1
    10. k0' <- Zq
    11. s0' <- Zq
    12. gamma0[0] <- Zq
    13. w[0] <- Zq
    14. z[0][0] <- Zq
    15. z[0][1] <- Zq
    16.
    17. if bits[0] == 0:
    18.     C'[0][0] = H2 * k0' + H3 * s0'
    19.     C'[0][1] = H2 * w[0] + H3 * z[0][1] - C[0][1] * gamma0[0]
    20. else:
    21.     C'[0][0] = H2 * w[0] + H3 * z[0][0] - C[0][0] * gamma0[0]
    22.     C'[0][1] = H2 * k0' + H3 * s0'

    23. // Process remaining bits (no k* component)
    24. For j = 1 to L-1:
    25.     C[j][0] = Com[j]
    26.     C[j][1] = Com[j] / H1
    27.     sj' <- Zq
    28.     gamma0[j] <- Zq
    29.     z[j][0] <- Zq
    30.     z[j][1] <- Zq
    31.
    32.     if bits[j] == 0:
    33.         C'[j][0] = H3 * sj'
    34.         C'[j][1] = H3 * z[j][1] - C[j][1] * gamma0[j]
    35.     else:
    36.         C'[j][0] = H3 * z[j][0] - C[j][0] * gamma0[j]
    37.         C'[j][1] = H3 * sj'

    38. // After challenge gamma is computed (externally):
    39. // Complete the proof with proper response values
    40.
    41. // For bit 0:
    42. if bits[0] == 0:
    43.     gamma0[0] = gamma - gamma0[0]
    44.     w00 = gamma0[0] * k* + k0'
    45.     w01 = w[0]
    46.     z[0][0] = gamma0[0] * s[0] + s0'
    47. else:
    48.     w00 = w[0]
    49.     w01 = (gamma - gamma0[0]) * k* + k0'
    50.     z[0][1] = (gamma - gamma0[0]) * s[0] + s0'

    51. // For remaining bits:
    52. For j = 1 to L-1:
    53.     if bits[j] == 0:
    54.         gamma0[j] = gamma - gamma0[j]
    55.         z[j][0] = gamma0[j] * s[j] + sj'
    56.     else:
    57.         z[j][1] = (gamma - gamma0[j]) * s[j] + sj'

    58. range_proof = (C', w00, w01, gamma0, z)
    59. return range_proof
]]></artwork></figure>

</section>
</section>
<section anchor="cryptographic-primitives"><name>Cryptographic Primitives</name>

<section anchor="protocol-version"><name>Protocol Version</name>

<t>The protocol version string for domain separation is:
~~~
PROTOCOL_VERSION = "curve25519-ristretto anonymous-credentials v1.0"
~~~</t>

<t>This version string <bcp14>MUST</bcp14> be used consistently across all implementations for interoperability. The curve specification is included to prevent cross-curve attacks and ensure implementations using different curves cannot accidentally interact.</t>

<t>Note: The reference implementation currently uses version "v0.2.0" while this specification defines version "v1.0". Implementations <bcp14>MUST</bcp14> use the exact version string for the protocol version they implement. Different version strings create incompatible protocols, which is intentional to prevent version downgrade attacks and ensure implementations are explicitly compatible.</t>

</section>
<section anchor="hash-function-and-fiat-shamir-transform"><name>Hash Function and Fiat-Shamir Transform</name>

<t>The protocol uses BLAKE3 <xref target="BLAKE3"/> as the underlying hash function for the Fiat-Shamir transform <xref target="ORRU-FS"/>. Following the sigma protocol framework <xref target="ORRU-SIGMA"/>, challenges are generated using a transcript that accumulates all protocol messages:</t>

<figure><artwork><![CDATA[
CreateTranscript(label):
  Input:
    - label: ASCII string identifying the proof type
  Output:
    - transcript: A new transcript object

  Steps:
    1. hasher = BLAKE3.new()
    2. hasher.update(PROTOCOL_VERSION)
    3. hasher.update(Encode(H1))
    4. hasher.update(Encode(H2))
    5. hasher.update(Encode(H3))
    6. hasher.update(len(label).to_be_bytes() || label)
    7. return transcript with hasher

AddToTranscript(transcript, value):
  Input:
    - transcript: Existing transcript
    - value: Element or Scalar to add

  Steps:
    1. encoded = Encode(value)
    2. transcript.hasher.update(len(encoded).to_be_bytes() || encoded)

GetChallenge(transcript):
  Input:
    - transcript: Completed transcript
  Output:
    - challenge: Scalar challenge value

  Steps:
    1. seed = transcript.hasher.finalize()
    2. rng = ChaCha20RNG(seed)
    3. return Scalar.random(rng)
]]></artwork></figure>

<t>This approach ensures:
- Domain separation through the label and protocol version
- Inclusion of all public parameters to prevent parameter substitution attacks
- Proper ordering with length prefixes to prevent ambiguity
- Deterministic challenge generation from the complete transcript</t>

</section>
<section anchor="encoding-functions"><name>Encoding Functions</name>

<t>Elements and scalars are encoded as follows:</t>

<figure><artwork><![CDATA[
Encode(value):
  Input:
    - value: Element or Scalar
  Output:
    - encoding: ByteString

  Steps:
    1. If value is an Element:
    2.     return value.compress()  // 32 bytes, compressed Ristretto point
    3. If value is a Scalar:
    4.     return value.to_bytes_le()  // 32 bytes, little-endian
]]></artwork></figure>

<t>Note: Implementations <bcp14>MAY</bcp14> use standard serialization formats (e.g., bincode, CBOR) for complex structures, but <bcp14>MUST</bcp14> ensure deterministic encoding for hash inputs.</t>

</section>
<section anchor="binary-decomposition"><name>Binary Decomposition</name>

<t>To decompose a scalar into its binary representation:</t>

<figure><artwork><![CDATA[
BitDecompose(s):
  Input:
    - s: Scalar value
  Output:
    - bits: Array of L scalars (each 0 or 1)

  Steps:
    1. bytes = s.to_bytes_le()  // 32 bytes, little-endian
    2. For i = 0 to L-1:
    3.     byte_index = i / 8
    4.     bit_position = i % 8
    5.     bit = (bytes[byte_index] >> bit_position) & 1
    6.     bits[i] = Scalar(bit)
    7. return bits
]]></artwork></figure>

<t>Note: This algorithm produces bits in LSB-first order (i.e., <spanx style="verb">bits[0]</spanx> is the least significant bit). The algorithm works for any L &lt; 252, as the scalar is represented in 32 bytes (256 bits), which accommodates the full range of the Ristretto group order.</t>

</section>
<section anchor="scalar-conversion"><name>Scalar Conversion</name>

<t>Converting between credit amounts and scalars:</t>

<figure><artwork><![CDATA[
CreditToScalar(amount):
  Input:
    - amount: Integer credit amount (0 <= amount < 2^L)
  Output:
    - s: Scalar representation

  Steps:
    1. if amount >= 2^L:
    2.     return ERROR
    3. return Scalar(amount)

ScalarToCredit(s):
  Input:
    - s: Scalar value
  Output:
    - amount: Integer credit amount or ERROR

  Steps:
    1. bytes = s.to_bytes_le()
    2. // Check high bytes are zero
    3. For i = 16 to 31:
    4.     if bytes[i] != 0:
    5.         return ERROR
    6. amount = bytes[0..15] as u128
    7. return amount
]]></artwork></figure>

</section>
</section>
</section>
<section anchor="protocol-messages-and-wire-format"><name>Protocol Messages and Wire Format</name>

<section anchor="message-encoding"><name>Message Encoding</name>

<t>All protocol messages <bcp14>SHOULD</bcp14> be encoded using deterministic CBOR (RFC 8949) for interoperability. The following sections define the structure of each message type.</t>

<section anchor="issuance-request-message"><name>Issuance Request Message</name>

<figure><artwork><![CDATA[
IssuanceRequestMsg = {
    1: bstr,  ; K (compressed Ristretto point, 32 bytes)
    2: bstr,  ; gamma (scalar, 32 bytes)
    3: bstr,  ; k_bar (scalar, 32 bytes)
    4: bstr   ; r_bar (scalar, 32 bytes)
}
]]></artwork></figure>

</section>
<section anchor="issuance-response-message"><name>Issuance Response Message</name>

<figure><artwork><![CDATA[
IssuanceResponseMsg = {
    1: bstr,  ; A (compressed Ristretto point, 32 bytes)
    2: bstr,  ; e (scalar, 32 bytes)
    3: bstr,  ; gamma_resp (scalar, 32 bytes)
    4: bstr,  ; z (scalar, 32 bytes)
    5: bstr   ; c (scalar, 32 bytes)
}
]]></artwork></figure>

</section>
<section anchor="spend-proof-message"><name>Spend Proof Message</name>

<figure><artwork><![CDATA[
SpendProofMsg = {
    1: bstr,           ; k (nullifier, 32 bytes)
    2: bstr,           ; s (spend amount, 32 bytes)
    3: bstr,           ; A' (compressed point, 32 bytes)
    4: bstr,           ; B_bar (compressed point, 32 bytes)
    5: [* bstr],       ; Com array (L compressed points)
    6: bstr,           ; gamma (scalar, 32 bytes)
    7: bstr,           ; e_bar (scalar, 32 bytes)
    8: bstr,           ; r2_bar (scalar, 32 bytes)
    9: bstr,           ; r3_bar (scalar, 32 bytes)
    10: bstr,          ; c_bar (scalar, 32 bytes)
    11: bstr,          ; r_bar (scalar, 32 bytes)
    12: bstr,          ; w00 (scalar, 32 bytes)
    13: bstr,          ; w01 (scalar, 32 bytes)
    14: [* bstr],      ; gamma0 array (L scalars)
    15: [* [bstr, bstr]], ; z array (L pairs of scalars)
    16: bstr,          ; k_bar (scalar, 32 bytes)
    17: bstr           ; s_bar (scalar, 32 bytes)
}
]]></artwork></figure>

</section>
<section anchor="refund-message"><name>Refund Message</name>

<figure><artwork><![CDATA[
RefundMsg = {
    1: bstr,  ; A* (compressed Ristretto point, 32 bytes)
    2: bstr,  ; e* (scalar, 32 bytes)
    3: bstr,  ; gamma (scalar, 32 bytes)
    4: bstr   ; z (scalar, 32 bytes)
}
]]></artwork></figure>

</section>
</section>
<section anchor="error-responses"><name>Error Responses</name>

<t>Error responses <bcp14>SHOULD</bcp14> use the following format:</t>

<figure><artwork><![CDATA[
ErrorMsg = {
    1: uint,   ; error_code
    2: tstr    ; error_message (for debugging only)
}
]]></artwork></figure>

<t>Error codes are defined in Section 5.3.</t>

</section>
<section anchor="protocol-flow"><name>Protocol Flow</name>

<t>The complete protocol flow with message types:</t>

<figure><artwork><![CDATA[
Client                                          Issuer
  |                                               |
  |-- IssuanceRequestMsg ------------------------>|
  |                                               |
  |<-- IssuanceResponseMsg -----------------------|
  |                                               |
  | (client creates token)                        |
  |                                               |
  |-- SpendProofMsg ----------------------------->|
  |                                               |
  |<-- RefundMsg or ErrorMsg ---------------------|
  |                                               |
]]></artwork></figure>

</section>
</section>
<section anchor="implementation-considerations"><name>Implementation Considerations</name>

<section anchor="nullifier-management"><name>Nullifier Management</name>

<t>Implementations <bcp14>MUST</bcp14> maintain a persistent database of used nullifiers to prevent double-spending. The nullifier storage requirements grow linearly with the number of spent tokens. Implementations <bcp14>MAY</bcp14> use the following strategies to manage storage:</t>

<t><list style="numbers" type="1">
  <t><strong>Expiration</strong>: If tokens have expiration dates, old nullifiers can be pruned.</t>
  <t><strong>Sharding</strong>: Nullifiers can be partitioned across multiple databases.</t>
  <t><strong>Bloom Filters</strong>: Probabilistic data structures can reduce memory usage with a small false-positive rate.</t>
</list></t>

</section>
<section anchor="constant-time-operations"><name>Constant-Time Operations</name>

<t>To prevent timing attacks, implementations <bcp14>MUST</bcp14> use constant-time operations for:</t>

<t><list style="symbols">
  <t>Scalar arithmetic</t>
  <t>Point operations</t>
  <t>Conditional selections in range proofs</t>
</list></t>

<t>In particular, the range proof generation <bcp14>MUST</bcp14> use constant-time conditional selection when choosing between bit values 0 and 1. The following pattern should be used:</t>

<figure><artwork><![CDATA[
ConstantTimeSelect(condition, value_if_true, value_if_false):
  // Returns value_if_true if condition is true (1),
  // value_if_false if condition is false (0)
  // Must execute in constant time regardless of condition
]]></artwork></figure>

<t>This is critical in the range proof generation where bit values must not leak through timing channels.</t>

</section>
<section anchor="randomness-generation"><name>Randomness Generation</name>

<t>The security of the protocol critically depends on the quality of random number generation. Implementations <bcp14>MUST</bcp14> use cryptographically secure random number generators (CSPRNGs) for:</t>

<t><list style="symbols">
  <t>Private key generation</t>
  <t>Blinding factors (r, k)</t>
  <t>Proof randomness (nonces)</t>
</list></t>

<section anchor="rng-requirements"><name>RNG Requirements</name>

<t><list style="numbers" type="1">
  <t><strong>Entropy Source</strong>: Use OS-provided entropy (e.g., /dev/urandom on Unix systems)</t>
  <t><strong>Fork Safety</strong>: Reseed after fork() to prevent nonce reuse</t>
  <t><strong>Backtracking Resistance</strong>: Use forward-secure PRNGs when possible</t>
</list></t>

</section>
<section anchor="nonce-generation"><name>Nonce Generation</name>

<t>Following <xref target="ORRU-SIGMA"/>, nonces (the randomness used in proofs) <bcp14>MUST</bcp14> be generated with extreme care:</t>

<t><list style="numbers" type="1">
  <t><strong>Fresh Randomness</strong>: Generate new nonces for every proof</t>
  <t><strong>No Reuse</strong>: Never reuse nonces across different proofs</t>
  <t><strong>Full Entropy</strong>: Use the full security parameter (256 bits) of randomness</t>
  <t><strong>Zeroization</strong>: Clear nonces from memory after use</t>
</list></t>

<t>WARNING: Leakage of even a few bits of a nonce can allow complete recovery of the witness (secret values). Implementations <bcp14>MUST</bcp14> use constant-time operations and secure memory handling for all nonce-related computations.</t>

</section>
</section>
<section anchor="point-validation"><name>Point Validation</name>

<t>All Ristretto points received from external sources <bcp14>MUST</bcp14> be validated:</t>

<t><list style="numbers" type="1">
  <t><strong>Deserialization</strong>: Verify the point deserializes to a valid Ristretto point</t>
  <t><strong>Non-Identity</strong>: Verify the point is not the identity element</t>
  <t><strong>Subgroup Check</strong>: Ristretto guarantees prime-order subgroup membership</t>
</list></t>

<t>Example validation:</t>

<figure><artwork><![CDATA[
ValidatePoint(P):
  1. If P fails to deserialize:
  2.     return INVALID
  3. If P == Identity:
  4.     return INVALID
  5. // Ristretto ensures prime-order subgroup membership
  6. return VALID
]]></artwork></figure>

<t>All implementations <bcp14>MUST</bcp14> validate points at these locations:</t>

<t><list style="symbols">
  <t>When receiving <spanx style="verb">K</spanx> in issuance request</t>
  <t>When receiving <spanx style="verb">A</spanx> in issuance response</t>
  <t>When receiving <spanx style="verb">A'</spanx> and <spanx style="verb">B_bar</spanx> in spend proof</t>
  <t>When receiving <spanx style="verb">Com[j]</spanx> commitments in spend proof</t>
  <t>When receiving <spanx style="verb">A*</spanx> in refund response</t>
</list></t>

</section>
<section anchor="error-handling"><name>Error Handling</name>

<t>Implementations <bcp14>SHOULD NOT</bcp14> provide detailed error messages that could leak information about the verification process. A single INVALID response should be returned for all verification failures.</t>

<section anchor="error-codes"><name>Error Codes</name>

<t>While detailed error messages should not be exposed to untrusted parties, implementations <bcp14>MAY</bcp14> use the following internal error codes:</t>

<t><list style="symbols">
  <t><spanx style="verb">INVALID_PROOF</spanx>: Proof verification failed</t>
  <t><spanx style="verb">INSUFFICIENT_BALANCE</spanx>: Attempting to spend more than available credits</t>
  <t><spanx style="verb">NULLIFIER_REUSE</spanx>: Double-spend attempt detected</t>
  <t><spanx style="verb">MALFORMED_REQUEST</spanx>: Request format is invalid</t>
  <t><spanx style="verb">INVALID_SIGNATURE</spanx>: BBS signature verification failed</t>
  <t><spanx style="verb">RANGE_PROOF_FAILED</spanx>: Range proof verification failed</t>
  <t><spanx style="verb">INVALID_AMOUNT</spanx>: Credit amount exceeds maximum (2^L - 1)</t>
</list></t>

</section>
</section>
<section anchor="parameter-selection"><name>Parameter Selection</name>

<t>The bit length L is configurable and determines the range of credit values (0 to 2^L - 1). The choice of L involves several trade-offs:</t>

<t><list style="numbers" type="1">
  <t><strong>Range</strong>: Larger L supports higher credit values</t>
  <t><strong>Performance</strong>: Proof size and verification time scale linearly with L</t>
  <t><strong>Security</strong>: L must be less than the bit length of the group order (252 bits for Ristretto)</t>
</list></t>

<t>Common configurations:</t>

<t><list style="symbols">
  <t>L = 32: Suitable for small credit systems (up to ~4 billion credits)</t>
  <t>L = 64: Suitable for medium-scale systems (up to ~18 quintillion credits)</t>
  <t>L = 128: Suitable for large-scale systems with effectively unlimited credit range</t>
  <t>L = 256: Maximum practical value, but with doubled proof sizes compared to L = 128</t>
</list></t>

<t>The implementation <bcp14>MUST</bcp14> enforce L &lt; 252 to ensure proper scalar arithmetic within the group order.</t>

<section anchor="performance-characteristics"><name>Performance Characteristics</name>

<t>The protocol has the following computational complexity:</t>

<t><list style="numbers" type="1">
  <t><strong>Issuance</strong>:
  <list style="symbols">
      <t>Client: 3 scalar multiplications + 1 hash</t>
      <t>Issuer: 1 exponentiation + 3 scalar multiplications + 1 hash</t>
    </list></t>
  <t><strong>Spending</strong>:
  <list style="symbols">
      <t>Client: O(L) scalar multiplications for range proof + O(1) for sigma protocol</t>
      <t>Issuer: O(L) scalar multiplications for verification</t>
    </list></t>
  <t><strong>Storage</strong>:
  <list style="symbols">
      <t>Token size: 5 Ã 32 bytes = 160 bytes (independent of L)</t>
      <t>Spend proof size: O(L) Ã 32 bytes (approximately 32L bytes)</t>
      <t>Nullifier database: 32 bytes per spent token</t>
    </list></t>
</list></t>

<t>The proof size scales linearly with L:</t>

<t><list style="symbols">
  <t>L = 32: ~1KB spend proof</t>
  <t>L = 64: ~2KB spend proof</t>
  <t>L = 128: ~4KB spend proof</t>
  <t>L = 256: ~8KB spend proof</t>
</list></t>

</section>
<section anchor="parameter-trade-offs"><name>Parameter Trade-offs</name>

<texttable>
      <ttcol align='left'>Parameter</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Maximum Credit Value</ttcol>
      <ttcol align='left'>Spend Proof Size</ttcol>
      <ttcol align='left'>Use Case</ttcol>
      <c>L</c>
      <c>32</c>
      <c>4,294,967,295</c>
      <c>~1 KB</c>
      <c>Small-scale systems, API rate limiting</c>
      <c>L</c>
      <c>64</c>
      <c>1.8 Ã 10^19</c>
      <c>~2 KB</c>
      <c>Medium-scale systems, micropayments</c>
      <c>L</c>
      <c>128</c>
      <c>3.4 Ã 10^38</c>
      <c>~4 KB</c>
      <c>Large-scale systems, general purpose</c>
      <c>L</c>
      <c>192</c>
      <c>6.3 Ã 10^57</c>
      <c>~6 KB</c>
      <c>Very large values, future-proofing</c>
</texttable>

<t>Implementations <bcp14>SHOULD</bcp14> choose L based on their maximum credit requirements and performance constraints. Note that L <bcp14>MUST</bcp14> be less than 252 to fit within the Ristretto group order.</t>

</section>
</section>
</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<section anchor="security-model-and-definitions"><name>Security Model and Definitions</name>

<section anchor="threat-model"><name>Threat Model</name>

<t>We consider a setting with:</t>

<t><list style="symbols">
  <t>A single trusted issuer (multiple issuers can operate independently)</t>
  <t>Potentially malicious clients who may attempt to forge tokens or double-spend</t>
  <t>An adversary who can observe all network communications</t>
  <t>Clients who desire privacy from the issuer regarding their spending patterns</t>
</list></t>

<t>Note: The issuer must be trusted not to:</t>

<t><list style="symbols">
  <t>Issue tokens without proper authorization</t>
  <t>Create tokens for themselves without limit</t>
  <t>Refuse valid spend proofs</t>
  <t>Manipulate the nullifier database</t>
</list></t>

<t>The protocol does not protect against a malicious issuer, only ensures privacy from an honest-but-curious issuer.</t>

</section>
<section anchor="security-properties"><name>Security Properties</name>

<t>The protocol provides the following security guarantees:</t>

<t><list style="numbers" type="1">
  <t><strong>Unforgeability</strong>: No probabilistic polynomial-time (PPT) adversary can create a valid credit token without the issuer's cooperation. Formally, for any PPT adversary A:  <vspace blankLines='1'/>
<spanx style="verb">
Pr[A(pk, params) -&gt; valid_token] â¤ negl(Î»)
</spanx>  <vspace blankLines='1'/>
where Î» is the security parameter.</t>
  <t><strong>Unlinkability</strong>: The issuer cannot link:
  <list style="symbols">
      <t>A spending transaction to the original issuance</t>
      <t>Multiple spending transactions by the same client</t>
    </list>
This holds under the DDH assumption in the Ristretto group.</t>
  <t><strong>Balance Security</strong>: No PPT adversary can spend more credits than issued. Specifically:
  <list style="symbols">
      <t>Credits cannot be created from nothing</t>
      <t>The sum of spent credits cannot exceed issued credits</t>
      <t>Each token can only be fully spent once (via nullifier checking)</t>
    </list></t>
  <t><strong>Zero-Knowledge</strong>: The spending proof reveals only:
  <list style="symbols">
      <t>The nullifier k</t>
      <t>The amount being spent s</t>
      <t>That the client possesses sufficient balance (c â¥ s)</t>
    </list>
No other information about c, r, or the token is revealed.</t>
  <t><strong>Nullifier Binding</strong>: The nullifier k is cryptographically bound to the token through the BBS signature. An adversary cannot:
  <list style="symbols">
      <t>Use a nullifier from one token with a different token</t>
      <t>Modify the nullifier without invalidating the signature</t>
    </list></t>
</list></t>

</section>
</section>
<section anchor="cryptographic-assumptions"><name>Cryptographic Assumptions</name>

<t>The security of Anonymous Credit Tokens relies on:</t>

<t><list style="numbers" type="1">
  <t><strong>Discrete Logarithm Problem (DLP)</strong>: Given g, h â G, it is computationally infeasible to find x such that h = g^x.</t>
  <t><strong>Decisional Diffie-Hellman (DDH) Assumption</strong>: Given (g, g^a, g^b, g^c) for random a, b, c, it is computationally infeasible to determine whether c = ab or c is random.</t>
  <t><strong>Random Oracle Model</strong>: The BLAKE3 hash function H is modeled as a random oracle, providing:
  <list style="symbols">
      <t>Collision resistance</t>
      <t>Pre-image resistance</t>
      <t>Unpredictability</t>
    </list></t>
  <t><strong>Sigma Protocol Security</strong>: The underlying sigma protocols satisfy <xref target="ORRU-SIGMA"/>:
  <list style="symbols">
      <t>Completeness: Honest proofs always verify</t>
      <t>Special soundness: From two accepting transcripts with the same commitment but different challenges, one can extract the witness</t>
      <t>Honest-verifier zero-knowledge: The proof reveals nothing beyond the validity of the statement</t>
    </list></t>
  <t><strong>Fiat-Shamir Security</strong>: The non-interactive proofs are secure in the random oracle model <xref target="ORRU-FS"/>:
  <list style="symbols">
      <t>The transcript includes all public values to prevent malleability</t>
      <t>Domain separation prevents cross-protocol attacks; deployments <bcp14>MUST</bcp14> use unique domain separators to prevent parameter collision attacks between different services</t>
      <t>Length-prefixing prevents ambiguity in parsing</t>
    </list></t>
</list></t>

</section>
<section anchor="privacy-properties"><name>Privacy Properties</name>

<t>The protocol provides the following privacy guarantees:</t>

<t><list style="numbers" type="1">
  <t><strong>Unlinkability</strong>: The issuer cannot link a token to its issuance request or link multiple spends by the same client.</t>
  <t><strong>Balance Privacy</strong>: The amount of credits in a token is not revealed during spending (only that it's sufficient for the transaction).</t>
</list></t>

<t>However, the protocol does NOT provide:</t>

<t><list style="numbers" type="1">
  <t><strong>Network-Level Privacy</strong>: IP addresses and network metadata can still link transactions.</t>
  <t><strong>Amount Privacy</strong>: The spent amount s is revealed to the issuer.</t>
  <t><strong>Timing Privacy</strong>: Transaction timing patterns could potentially be used for correlation.</t>
</list></t>

</section>
<section anchor="security-properties-1"><name>Security Properties</name>

<t>The protocol ensures:</t>

<t><list style="numbers" type="1">
  <t><strong>Unforgeability</strong>: Clients cannot create valid tokens without the issuer's cooperation.</t>
  <t><strong>Non-Transferability</strong>: While tokens can be shared, this requires sharing the entire token state.</t>
  <t><strong>Double-Spend Prevention</strong>: Each token can only be fully spent once due to nullifier checking.</t>
</list></t>

</section>
<section anchor="implementation-vulnerabilities"><name>Implementation Vulnerabilities</name>

<t>Implementers should be aware of:</t>

<t><list style="numbers" type="1">
  <t><strong>RNG Failures</strong>: Weak randomness can completely break the protocol's security. Implementations <bcp14>MUST</bcp14>:
  <list style="symbols">
      <t>Use cryptographically secure RNGs</t>
      <t>Reseed after fork() operations</t>
      <t>Implement forward-secure RNG state management</t>
    </list></t>
  <t><strong>Timing Attacks</strong>: Variable-time operations can leak information about secret values. Critical operations requiring constant-time implementation:
  <list style="symbols">
      <t>Scalar arithmetic in proofs</t>
      <t>Binary decomposition in range proofs</t>
      <t>Conditional selections based on secret bits</t>
    </list></t>
  <t><strong>Nullifier Database Integrity</strong>: Corruption of the nullifier database could enable double-spending. Implementations <bcp14>SHOULD</bcp14>:
  <list style="symbols">
      <t>Use atomic database operations</t>
      <t>Implement database backups</t>
      <t>Include integrity checks (e.g., Merkle trees)</t>
    </list></t>
  <t><strong>Nullifier Collisions</strong>: While nullifiers are 256-bit values with negligible collision probability (approximately 2^-128 for 2^64 tokens), implementations should still handle potential collisions gracefully.</t>
  <t><strong>Serialization Attacks</strong>: Implementations <bcp14>MUST</bcp14> use canonical serialization for all values included in hash computations to prevent malleability attacks.</t>
  <t><strong>Concurrent Access</strong>: The protocol does not specify thread-safety requirements. Implementations <bcp14>SHOULD</bcp14> document their concurrency model and use appropriate locking mechanisms.</t>
</list></t>

</section>
<section anchor="protocol-composition-and-state-management"><name>Protocol Composition and State Management</name>

<section anchor="atomicity-requirements"><name>Atomicity Requirements</name>

<t>The spend and refund operations <bcp14>MUST</bcp14> be treated as an atomic transaction. If the refund fails after a spend proof is accepted, credits could be permanently lost. Implementations <bcp14>SHOULD</bcp14>:</t>

<t><list style="numbers" type="1">
  <t>Use two-phase commit or similar mechanisms</t>
  <t>Implement rollback capabilities for failed refunds</t>
  <t>Log all state transitions for recovery</t>
</list></t>

</section>
<section anchor="session-management"><name>Session Management</name>

<t>Each protocol session (issuance or spend/refund) <bcp14>MUST</bcp14>:
- Use fresh randomness
- Complete without interruption
- Not reuse any random values across sessions</t>

</section>
<section anchor="version-negotiation"><name>Version Negotiation</name>

<t>To support protocol evolution, implementations <bcp14>MAY</bcp14> include version negotiation in the initial handshake. All parties <bcp14>MUST</bcp14> agree on the protocol version before proceeding.</t>

</section>
</section>
<section anchor="quantum-resistance"><name>Quantum Resistance</name>

<t>This protocol is NOT quantum-resistant. The discrete logarithm problem can be solved efficiently by quantum computers using Shor's algorithm. Organizations requiring long-term security should consider post-quantum alternatives.</t>

</section>
</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t>This document has no IANA actions.</t>

</section>


  </middle>

  <back>


<references title='References' anchor="sec-combined-references">

    <references title='Normative References' anchor="sec-normative-references">



<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="S. Bradner" initials="S." surname="Bradner"/>
    <date month="March" year="1997"/>
    <abstract>
      <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>
<reference anchor="RFC8174">
  <front>
    <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
    <author fullname="B. Leiba" initials="B." surname="Leiba"/>
    <date month="May" year="2017"/>
    <abstract>
      <t>RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="8174"/>
  <seriesInfo name="DOI" value="10.17487/RFC8174"/>
</reference>
<reference anchor="RFC8949">
  <front>
    <title>Concise Binary Object Representation (CBOR)</title>
    <author fullname="C. Bormann" initials="C." surname="Bormann"/>
    <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
    <date month="December" year="2020"/>
    <abstract>
      <t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t>
      <t>This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format.</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="94"/>
  <seriesInfo name="RFC" value="8949"/>
  <seriesInfo name="DOI" value="10.17487/RFC8949"/>
</reference>
<reference anchor="RFC9380">
  <front>
    <title>Hashing to Elliptic Curves</title>
    <author fullname="A. Faz-Hernandez" initials="A." surname="Faz-Hernandez"/>
    <author fullname="S. Scott" initials="S." surname="Scott"/>
    <author fullname="N. Sullivan" initials="N." surname="Sullivan"/>
    <author fullname="R. S. Wahby" initials="R. S." surname="Wahby"/>
    <author fullname="C. A. Wood" initials="C. A." surname="Wood"/>
    <date month="August" year="2023"/>
    <abstract>
      <t>This document specifies a number of algorithms for encoding or hashing an arbitrary string to a point on an elliptic curve. This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9380"/>
  <seriesInfo name="DOI" value="10.17487/RFC9380"/>
</reference>

<reference anchor="RISTRETTO" target="https://ristretto.group/">
  <front>
    <title>The Ristretto Group</title>
    <author >
      <organization></organization>
    </author>
    <date />
  </front>
</reference>
<reference anchor="BLAKE3" target="https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf">
  <front>
    <title>BLAKE3: One Function, Fast Everywhere</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="January" day="09"/>
  </front>
</reference>


    </references>

    <references title='Informative References' anchor="sec-informative-references">



<reference anchor="RFC9474">
  <front>
    <title>RSA Blind Signatures</title>
    <author fullname="F. Denis" initials="F." surname="Denis"/>
    <author fullname="F. Jacobs" initials="F." surname="Jacobs"/>
    <author fullname="C. A. Wood" initials="C. A." surname="Wood"/>
    <date month="October" year="2023"/>
    <abstract>
      <t>This document specifies an RSA-based blind signature protocol. RSA blind signatures were first introduced by Chaum for untraceable payments. A signature that is output from this protocol can be verified as an RSA-PSS signature.</t>
      <t>This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9474"/>
  <seriesInfo name="DOI" value="10.17487/RFC9474"/>
</reference>

<reference anchor="ORRU-SIGMA" target="https://www.ietf.org/archive/id/draft-orru-zkproof-sigma-protocols-00.txt">
  <front>
    <title>Sigma Protocols</title>
    <author >
      <organization></organization>
    </author>
    <date year="2025" month="January" day="19"/>
  </front>
</reference>
<reference anchor="ORRU-FS" target="https://mmaker.github.io/draft-zkproof-sigma-protocols/draft-orru-zkproof-fiat-shamir.html">
  <front>
    <title>The Fiat-Shamir Transform</title>
    <author >
      <organization></organization>
    </author>
    <date year="2025" month="January" day="19"/>
  </front>
</reference>
<reference anchor="BBS" target="https://crypto.stanford.edu/~dabo/pubs/papers/groupsigs.pdf">
  <front>
    <title>Short Group Signatures</title>
    <author >
      <organization></organization>
    </author>
    <date year="2004"/>
  </front>
</reference>
<reference anchor="KVAC" target="https://eprint.iacr.org/2013/516.pdf">
  <front>
    <title>Keyed-Verification Anonymous Credentials</title>
    <author >
      <organization></organization>
    </author>
    <date year="2014"/>
  </front>
</reference>


    </references>

</references>


<?line 1259?>

<section anchor="test-vectors"><name>Test Vectors</name>

<t>This appendix provides test vectors for implementers to verify their implementations. All values are encoded in hexadecimal. Scalars are 32 bytes each.</t>

<section anchor="test-configuration"><name>Test Configuration</name>

<figure><artwork><![CDATA[
RNG Seed: 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20
Domain Separator: "anonymous-credit-tokens-v1"
Protocol Version: "curve25519-ristretto anonymous-credentials v1.0"
L: 128 (configurable parameter for this example)
]]></artwork></figure>

</section>
<section anchor="complete-protocol-flow-example"><name>Complete Protocol Flow Example</name>

<t>This example demonstrates issuing 100 credits and spending 30.</t>

<section anchor="issuance-phase-100-credits"><name>1. Issuance Phase (100 credits)</name>

<figure><artwork><![CDATA[
Credits to issue: 100
Token successfully created
Token balance: 100
Token nullifier (k): 0x6014ab1f6729d791c5a40752ff015efd3a33187a22f6b51f5914d2c22ce67805
]]></artwork></figure>

</section>
<section anchor="spending-phase-30-credits"><name>2. Spending Phase (30 credits)</name>

<figure><artwork><![CDATA[
Amount to spend: 30
Nullifier revealed: 0x6014ab1f6729d791c5a40752ff015efd3a33187a22f6b51f5914d2c22ce67805
Spend amount (s): 30

Refund issued successfully
New token balance: 70
New token nullifier (k*): 0xe844bad01bd4f034fcdd5c594960b7860abf46f8f5b876f600ffff16e0de1b07
]]></artwork></figure>

</section>
</section>
<section anchor="edge-cases"><name>Edge Cases</name>

<section anchor="zero-credit-token"><name>Zero Credit Token</name>

<figure><artwork><![CDATA[
Zero credit token created
Balance: 0
Nullifier: 0x603fdef3d44fbc72098e638618daf2079f9034f803492794791cdc77d9909b04
]]></artwork></figure>

</section>
<section anchor="maximum-credit-token"><name>Maximum Credit Token</name>

<figure><artwork><![CDATA[
Maximum credit token created
Balance: 340282366920938463463374607431768211455 (2^128 - 1)
Nullifier: 0x4997bd7475c72eed6065c545e791475d4192059d6f41279f794504233df19a06
]]></artwork></figure>

</section>
<section anchor="invalid-operation-overspend"><name>Invalid Operation: Overspend</name>

<figure><artwork><![CDATA[
Token balance: 20
Attempting to spend: 30
Result: INVALID (correctly rejected)
]]></artwork></figure>

</section>
<section anchor="double-spend-prevention"><name>Double-Spend Prevention</name>

<figure><artwork><![CDATA[
Original token balance: 50
First spend: 20
Nullifier: 0x5534aae1691f76607a32586128cd11553a51d5ae749b852c98f103333dc85804

Attempting second spend from original token: 15
Nullifier: 0x5534aae1691f76607a32586128cd11553a51d5ae749b852c98f103333dc85804
Same nullifier: true
Result: Would be rejected by nullifier database
]]></artwork></figure>

</section>
</section>
<section anchor="intermediate-test-values"><name>Intermediate Test Values</name>

<t>For debugging implementations, here are the expected intermediate values for the main test case (100 credits, spend 30):</t>

<section anchor="binary-decomposition-of-c-s-70"><name>Binary Decomposition of c - s = 70</name>

<figure><artwork><![CDATA[
m = 70 = 0x46
Binary: 01000110 (LSB first)
i[0] = 0, i[1] = 1, i[2] = 1, i[3] = 0,
i[4] = 0, i[5] = 0, i[6] = 1, i[7] = 0
i[8..L-1] = 0 (where L = 128 for this example)
]]></artwork></figure>

</section>
<section anchor="protocol-message-sizes"><name>Protocol Message Sizes</name>

<figure><artwork><![CDATA[
IssuanceRequestMsg: 4 Ã 32 = 128 bytes
IssuanceResponseMsg: 5 Ã 32 = 160 bytes
SpendProofMsg: O(L) Ã 32 bytes (e.g., ~4,096 bytes with L=128)
RefundMsg: 4 Ã 32 = 128 bytes
]]></artwork></figure>

</section>
</section>
<section anchor="test-vector-summary"><name>Test Vector Summary</name>

<t>These test vectors demonstrate:
1. Successful issuance and spending with correct balances
2. Edge cases (zero and maximum credit amounts) work correctly
3. Invalid operations (overspending) are properly rejected
4. Double-spend prevention through nullifier reuse detection
5. Correct binary decomposition for range proofs</t>

<section anchor="implementation-validation"><name>Implementation Validation</name>

<t>Implementations can validate correctness by:
1. Reproducing the nullifier values with the same RNG seed
2. Verifying balance calculations after spending
3. Ensuring invalid operations are rejected
4. Checking that double-spends produce identical nullifiers</t>

<t>Note: Full cryptographic values (points, signatures) depend on the specific implementation's representation and cannot be compared directly across implementations.</t>

</section>
</section>
</section>
<section anchor="implementation-status"><name>Implementation Status</name>

<t>This section records the status of known implementations of the protocol defined by this specification at the time of posting of this Internet-Draft, and is based on a proposal described in RFC 7942.</t>

<section anchor="anonymous-credit-tokens"><name>anonymous-credit-tokens</name>

<t>Organization: Google</t>

<t>Description: Reference implementation in Rust</t>

<t>Maturity: Beta</t>

<t>Coverage: Complete protocol implementation</t>

<t>License: Apache 2.0</t>

<t>Contact: sgschlesinger@gmail.com</t>

<t>URL: https://github.com/SamuelSchlesinger/anonymous-credit-tokens</t>

</section>
</section>
<section anchor="acknowledgments"><name>Acknowledgments</name>

<t>The authors would like to thank the Crypto Forum Research Group for their valuable feedback and suggestions. Special thanks to the contributors who provided implementation guidance and security analysis.</t>

<t>This work builds upon the foundational research in anonymous credentials and zero-knowledge proofs by numerous researchers in the cryptographic community, particularly the work on BBS signatures by Boneh, Boyen, and Shacham, and keyed-verification anonymous credentials by Chase, Meiklejohn, and Zaverucha.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAMroQGgAA+192XYbR5bgO74imjozAlkAiMRGErbcBVEbRxSlJii7XB6b
SgABMk0ACWcmuMiyn3u+YF7nYeYr+m3mvT+iv2TuFksmEiTtU4+NKotAZqw3
btw9btTr9cqTJ08qT9TRItPJQmf1F0k4zdS7MLmaxDcLdabny1mY6QoWOtWL
cK5VdhmlahrNtJom8VxNsEY9iydx/S5eJVikvkziLB7Hs8Z8orJYXehMpVmY
ZHrSgHa4D2prGifzMFPQ4Ba387Vp45v61zdxcnWRxKslfKdH0NxWg4byKk5U
tIiyKJypVGerZU1BRRUvZndqoTX1qidRBoOFTqIkzdRoFo+vVDyFn3o2SXEg
77H4VhZlM71F1VKsN9JqfBkuLvTkKzXRM51ptRWORom+3lLRFPtJFNXBYaeX
cZJhW4PFnYqht0SNYwDmIlPjcIFt4TD0pKZGq4yaDhM9Xc3UIs6ws2iRJfFk
NYZySRInNKxhjJChUaqbaDbDajBJFa6yGKAVjcMZjHuySqLFBc8exwV93ylo
XK0WMnwG1Yt48RQgvBjPVhOYSb3Z3FIAva06rmuawZwWAqUZrS+O4Dgc6Vlq
38AiqUcsj7TIg0hhEUZ30Ba2kMXxjGALcwcIwRd8Ol4lCQLqWidpFC++grnA
ACfxGFvbwm6Vvg0BATXP5AwRLxOMxB5SdZWEc0TUejId99Vlli3T/u7uRZRd
rkaNcTzfHYejeNcvBe18D5iCi5NoaGmsaSwwjihhIMgiqyUPNlSTaApfcKSM
rgihQwKxBRwMFNYcZ4GTgzLjSws6wO9q43Y+own97d1xTels3Gg0tnFSsPsI
l/pqa7CIF3fzeJWqw4Rw9yy+gja3Kox8WOLwbKsyhslfxMldH5ZnGlcqAq++
rFA6vpzpFDBDJ/XxNLmoh+NMFqaSrkbzKMVRZndLqHF0evZKqScqnKUxNB8t
Jnqp4Z9FtlVTWziGOIEdhj+OBs/hD+INVtqqLFbzkU76lQm03K8Ayqcw1FXa
V1my0hUYbLsCaBD21fDlYcViSl8dvjp9XbnSd/Bo0q+ougrtrMcwa1wGGA2+
WCbRdTi+w6/j5G6ZxRdJuLyk3591EtevFvHNTE9gEYDaxFOq8/z5UKXRxSLM
VommJ9AVICJgWDSFfZPB1CvXerGCMSvlD0kpBsmpTnWYwOq9xpfweB5Gs75C
SP410tm0EScX8BSLOHzDMvgkutYNU2gXH+yOkvgm1btYfRd7JMQEoITzlZ4N
3VLtYrW6hUV9TBgAVBUxACryAroeU2rAW+uG4HwU39vU7mYkaVxm81mlAkQG
SBouDXSrFJCqGaMXj1l5g6YCMNVwEX0m0PbV6zi+mGl6oRly6YXX2V8v8CFu
zPX2/1sMywa7Sr0Ns8+PavrnK0aMv17QK2q2sqAdByuBK3z66rAVBAfydT/Y
65ivBx3z9KC936SvR8Oz05dnZ+/71IfZlWewi0+jNEt0BjubsGKLC4QJ8DW3
JIkp1CC82qVCtD3UFFAaR/78ePD2ZTvfvjwDXqTVKyDdONmaehUCHX0JaHt3
AyxFl/fokTlupZ7p0H5Pl3qc7gLXGwF+psDe4Xt4pduN5WTqja3VbDXrzaDe
PKhUkKDkoXfQYZC9Pz39WB8evX43yI9+GMGKqg/C7tPycd7c3OS3BbS/G00E
F+MkWdU/X9EmrqfYnhUfUmBWjew2yw+3i8MNDsyoXg3XF+xVFGb14WU4jxJ1
loSLFOdVPrj5HIDibx8e1YYBlY15ip2l1BnvoQ2jBeJUAB7KDoxSamipVvkw
GdMbIEXhGk0aerLa/X2CzG25GqW7y3AJTHSXMA+GnK4tcrMDP99+OzjMD+Et
ksf6tx55VHk2JAS5fFAaaPQia0ThOKG1bTWD9m436K31HnQqFeB4lUq9DhR/
BBsFCE6lQgwd+NdqjswVERaGAVx9AydUVWCA2zXgyMIbYF2AXCfXKActwztq
xSyVGoUogsCEiAXUfRZQznQaClHH1gdhaAR0C4S8dAWwJTkWUAkEVxhugkKY
YtKqrsPZSlOB8SyCxtKaurmMScRAup0o7EPPUSBItVRK3RhAlru5RBkCZnON
Y4HZTOIVdI57eDHB39klrOwFyxQg+KAYuwDKieBKZOBAZvVcxCJAtXqa3UGb
jhtCh5NyzknCMnBvkH9GIMKCGAaSWZTdUQ0BNazdplVBcW8Jwn00XgEXhNmk
qyhD2JHAc6NHitZojCC6BGHIyOcRSna0ZgnKc7NoHuHcawCuFKRMEMxAzo15
xUj0mEfjJJZ1Th3MDAbAzBM73PxapqvlEvZayuNEnUEAW6M+brC6rB2OjN4i
mkEdRJeYpGugJW7tJjDKsQZCJrpCTlaG8iFM88bDM2K/jSLKw3dEZlQAMukF
gIs7HTWc1bwgjqgqyirbpi+UxGRPzaPJBJgja3LcHoo6lXchqiWLWbTQbhVo
AeYaBx6lc5qxQFpb2AMOb1yfGMEcQ5k0vyQNpLUAH+gZQBwuoVAISJmKvJ/S
ggBeYJd3S1FjEv3LCiVvJAlXdhkj2pTZHe6kCKafhBHitawuqlhj0Fehx3tJ
BfZ3DU0BkD0RMhqrNJ6taGUJIc1Od2ga866ndaaB2ZW/AT4RgyYHEKXRZshd
QoI21fNHD6SMVlxvGKXDT8IDon/hTAQeRIfHUi71669I2n/7jeczBfRCaEHx
DbSqoY4yxvy0X6kEDbWz44Z4BFMPAb47O30YuNA/omZM/wwoEG1k1ziwALYu
EC6Id/yuLnR9rKx4EaNifBcjcC8NQVQhdA7MpFJp5YczlK2KwzmUPYqD4U2a
35dmGEhIAZJEOPG9QSdEXbNy89UsiwDDc0sI3bex+w9CJ+7v/JEUAieZoMwK
qhXok+lG4tDBrl8w6aeeQbJilhAvcAQvYTsZcFEddYmtAVakaQy4k8G+tmyB
cUF4SkqDSNHkYkZIxpuRJhvCEtfQASSaE+Y+eaI+wqY9BEaabib/YuaA7Q7w
IcJ+HSYRlkvHsLPgK+JYHWZ2imTkWMgIzmdoNhy2wTtuApL9nUUJxFBEReEc
uLlSA3uPfSKfGXw4UkhRUlxjx0HGSKYa1P0HERo+OJbxzidfOKKP1AMOZwn1
AboWPUerxWQmXNSiHpD6a4Q0AMziHpQPiYeHPmYpoPugTd/xUBwsz6LxlTbw
eIlLZdQeMxCGCzU11Qnx1YwqCVAE/kwlYAHMOCxBjW8W0NZltBRWJeA4NTAa
WC7LWB6vJo4UYuuWOYCmsVxloRB4yypgXYiBmk14L2MmtDIKg3p/jWX0DZNJ
Rw8X1/HsGpf9JmaerdO+Ci0xqjr+EZqxGmKfbNMaGXZeZaQR5iplt1k+iNDq
KeszjYkcoqSlNWr9gAK4/pZADtHQhhCimjyOCw2gRdUchgHEGoYKJICkJtjD
UUq8D+eFv8ZYwpC3HI01RBRZIWj5aX6LZra7ht81oRl1DG0jThpBT8ULn6wS
wacxGWJdH1/GqV44SlETEYSR1qcvhhz6ZPDMyEcyyhr3ZqaAhJdn7SgRy5Ex
LugyTgGmqdDMEIcXTYSYIeaCqDYFXkGNjcIZwig3bUFzgSuKrzVAaz2+KvYJ
a4d2z5GGhtkYqYFM6BoNhhozdJg7RxqCTIsJNYLCdE8Y+0IjgNXrGK1TBWQF
gY7eyuYTOdDIlRdYRSigkKACFsEeQ2swMqYc9I0sytzTILSwsHL+pUZ3HqWn
GrzbhyLTFxgZ9surOQfgONaOdhgyKMt6Ya+od6xxkSLTwL5eygryRIG8qHiJ
24QGmAJxmk3IEu5TE9jJ2ix8La9BXEYXl3WgBysksp42IRNDMRXqZRaqTuq3
XaHCCa1k0NxNmBS0D0IIoAQXJObCN9CGboFaE2e8SzOQVxkHTvWMhRco8dKU
+C5OrkSsd6rnKkLb/WoJZVPYEQnJX74ACtQQ2eC1NpiBlktnA9jZAZEOHv32
G09pjIvjdrioejnh1ULPKHWwvdxmM7DKWWuoF2fZMZ2V6YhAimDV0Y7LmwnX
xSqn3CF3UWp5cR29slPKQP9YRL8ga0OD+RXjlqXI11Y5BVZZ9x43CrvPsD9g
IjCuMCdIa1xYNJmALPfnZep4CbhNjeGsnUQtaj8Rt4JaifiiDuOFyG5c6IWe
kssKfvMckGOgHTxVW+8+Ds/QzI5/1cl7+n768l8+Hp2+fIHfh28Gx8f2S0VK
DN+8/3j8wn1zNQ/fv3v38uQFV4anKveosvVu8P0Wk8Kt9x/Ojt6fDI7FEeSr
p6jZs0OMFgBYekYwrgC9GyfRiOCrnh9++L//K+gAwP5J7K0ANP6BFlf4cXOp
F9wbOej4J5KXCkiNoDFgK0ACYC2XsO9nwFJCIhQ3IDbpBJd85weEzI999fVo
vAw638gDnHDuoYFZ7iHBbP3JWmUGYsmjkm4sNHPPC5DOj3fwfe63gbv38Ot/
JkW9Huz/8zcVIjknMRPIouGA9Ls8n1lIUSIon758+dRHDES5bWGRf3SXETGE
8imWulVf19XwExn3l6Qv3arVIsI9i6IVav6LCcggVhBBN+SQa/afqTuoOUiR
LtGgRMZiiePOePlQGyBafov1flj8+IkJADYFNYjyooT2a7OmgppqNBo1tagH
v9Esbr9I6ZleXABrzc+Bm2zefiJfXXTbV2/0bTiB3T+3+5O5d5iF6uxuqYu8
uwSOEyyLziBDmoew2cPEaMM8XGCXk9WMJ0hGV2CQqNz9wgyQOQsLd8s4Qtiw
UOY8CcCOrzWTfpjQkObDFVIUA0HwMJPlKRzm+Afop0CPYU9unJDricf366/W
wfHbb8asIiIzW6GAgdd5FlzD2GkJd1DNOcQht7rd4IBFMpZ4zUCQWgjEfnGs
GDUjblSwg9uutn5qdVvqL6q1t9dptYM9+LT3Wu0u/m8femjv7R009/fbvc5+
56C9Tc2+Ns0iSZ8gHxf5O7atF2ZN1Y5NtVGUGTxCSp633lbH8WIaXaxIw6p5
BqqgtY81022k6VZxGYpYJrsTFmhIosLmlRFDVxHdWMLw4Agw/P333ysfvAdK
1dXrvnr90Gyx3BvYQ29a8F8bcGlirXEWUinPPZ6D/EFqL9U67qvnfwA681UK
ciPMPZ3eqWP1tYLF3KZh05y9zsxwkPi/aSsi2iNbAhjIBOc4B8aYmsAGIjYh
0rNLAFB9tazP7+rpTIMgJbTF2att0IPnu0boaLSUcDgGsZ2pet1QIqSJQSTM
shDVBnKwgQSCQiTKAB5Gj0l+RDkVhhSl2lrGG0iYRQBjy6Y35ZLhkIZ0GUe8
qY9liWU9tVvqKhBb0D7OU42jgNa2cfGPFiAns9+mroolYOEs/RA71/ROLF8A
3OUsJusGestWmdcOTROU6mER/1TVoRDgvFLDTC9TrgaKcIrG42fiylwfLxUD
FTeBETzDKAn4f6t5evK6ihX5NaiUbwJ4+yZML89ii8RVqNNY6Nusus3lOlCu
9Yhy3Qai1sPlejAsUOKTRX6KFm15Mv/dzcai64olVYpIQcxycPVwMS/hR2k8
M6bO7Aa1UBdGYjUYtuh5rYm8gapWKONRbjiEb7LGRge2+qE0Wsu5zWtGcRuH
qUa9CroD2WprfifFKTzkOuCQIIm2qYO6sZS4gRRfNtRHsvAQkkNXxYGloJFe
YZRUedABtR+Okzj19EU36dTaMqzjKYlSUujZ6WVxE7YiqPcpy+wTuzrhdQxA
IVl0aX0fedXtLZAJ2W4iTT1gw0mNQUj2KjQA9avefgQSsNBr2yq96ivS8jPm
j1WWHrbNrsPX1hqkqiIplOwzEs3+/ovZT98Bfr9WOyDxyA5Kr+DJrdknS/z1
ndkNBsvTqxq8EQwHKLDXwdieHBTwV94ZsShqYqLYCipbu38oNnyGZR97eSL2
hb7tCBRnMmwxJPGplifVJYxwvE7kEExULnmaetYzeTvuGxM0+wxUtam+fqbG
yId+Ot5eWxOxq3kDkidmzTJyU/Ow+RdtdXbe5mKH1pbpipdJqd1dAa/dn4ml
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
t4T2vAAA

-->

</rfc>

